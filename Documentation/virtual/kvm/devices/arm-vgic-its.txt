ARM Virtual Interrupt Translation Service (ITS)
===============================================

Device types supported:
  KVM_DEV_TYPE_ARM_VGIC_ITS    ARM Interrupt Translation Service Controller

The ITS allows MSI(-X) interrupts to be injected into guests. This extension is
optional.  Creating a virtual ITS controller also requires a host GICv3 (see
arm-vgic-v3.txt), but does not depend on having physical ITS controllers.

There can be multiple ITS controllers per guest, each of them has to have
a separate, non-overlapping MMIO region.


Groups:
  KVM_DEV_ARM_VGIC_GRP_ADDR
  Attributes:
    KVM_VGIC_ITS_ADDR_TYPE (rw, 64-bit)
      Base address in the guest physical address space of the GICv3 ITS
      control register frame.
      This address needs to be 64K aligned and the region covers 128K.
  Errors:
    -E2BIG:  Address outside of addressable IPA range
    -EINVAL: Incorrectly aligned address
    -EEXIST: Address already configured
    -EFAULT: Invalid user pointer for attr->addr.
    -ENODEV: Incorrect attribute or the ITS is not supported.


  KVM_DEV_ARM_VGIC_GRP_CTRL
  Attributes:
    KVM_DEV_ARM_VGIC_CTRL_INIT
      request the initialization of the ITS, no additional parameter in
      kvm_device_attr.addr.
  Errors:
    -ENXIO:  ITS not properly configured as required prior to setting
             this attribute
    -ENOMEM: Memory shortage when allocating ITS internal data

  KVM_DEV_ARM_VGIC_GRP_ITS_REGS
  Attributes:
      The attr field of kvm_device_attr encodes the offset of the
      ITS register, relative to the ITS control frame base address
      (ITS_base).

      kvm_device_attr.addr points to a __u64 value whatever the width
      of the addressed register (32/64 bits).

      Writes to read-only registers are ignored by the kernel except
      for a single register, GITS_READR. Normally this register is RO
      but it needs to be restored otherwise commands in the queue will
      be re-executed after CWRITER setting.

      For other registers, Getting or setting a register has the same
      effect as reading/writing the register on real hardware.
  Errors:
    -ENXIO: Offset does not correspond to any supported register
    -EFAULT: Invalid user pointer for attr->addr
    -EINVAL: Offset is not 64-bit aligned

  KVM_DEV_ARM_VGIC_GRP_ITS_TABLES
  Attributes
       The attr field of kvm_device_attr is not used.

       request the flush-save/restore of the ITS tables, namely
       the device table, the collection table, all the ITT tables,
       the LPI pending tables. On save, the tables are flushed
       into guest memory at the location provisioned by the guest
       in GITS_BASER (device and collection tables), on MAPD command
       (ITT_addr), GICR_PENDBASERs (pending tables).

       This means the GIC should be restored before the ITS and all
       ITS registers but the GITS_CTRL must be restored before
       restoring the ITS tables.

       Note the LPI configuration table is read-only for the
       in-kernel ITS and its save/restore goes through the standard
       RAM save/restore.

       The layout of the tables in guest memory defines an ABI.
       The entries are laid in little endian format as follows;

    The device table and ITE are respectively indexed by device id and
    eventid. The collection table however is not indexed by collection id:
    CTE are written at the beginning of the buffer.

    Device Table Entry (DTE) layout: entry size = 8 bytes

    bits:     | 63 ... 45 | 44 ... 5 | 4 ... 0 |
    values:   |   next    | ITT_addr |  Size   |

    where
    - ITT_addr matches bits [48:8] of the ITT address (256B aligned).
    - next field is meaningful only if the entry is valid (ITT_addr != NULL).
    It equals to 0 if this entry is the last one; otherwise it corresponds
    to the minimum between the offset to the next device id and 2^19 -1.

    Collection Table Entry (CTE) layout: entry size = 8 bytes

    bits:     | 63| 62 ..  52  | 51 ... 16 | 15  ...   0 |
    values:   | V |    RES0    |  RDBase   |    ICID     |

    Interrupt Translation Entry (ITE) layout: entry size = 8 bytes

    bits:     | 63 ... 48 | 47 ... 16 | 15 ... 0 |
    values:   |    next   |   pINTID  |  ICID    |

    - next field is meaningful only if the entry is valid (pINTID != NULL).
    It equals to 0 if this entry is the last one; otherwise it corresponds
    to the minimum between the eventid offset to the next ITE and 2^16 -1.

    LPI Pending Table layout:

    As specified in the ARM Generic Interrupt Controller Architecture
    Specification GIC Architecture version 3.0 and version 4. The first
    1kB is not modified and therefore should contain zeroes.
